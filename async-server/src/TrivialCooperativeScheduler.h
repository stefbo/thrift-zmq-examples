
#ifndef H06FC1744_A51C_4B59_8363_B313BF18EF8F
#define H06FC1744_A51C_4B59_8363_B313BF18EF8F

#include <thrift/Thrift.h>

#include <chrono>
#include <functional>
#include <iostream>
#include <string>
#include <mutex>
#include <vector>
#include <memory>
#include <utility>

using namespace std;

/// A task executed by the cooperative scheduler.
///
/// Has to implement @ref doProgress. Can optionally implement @cancel to
/// do cleanup work before being destroyed by the scheduler.
///
class Task
{
 public:
  Task() : startTime_(chrono::steady_clock::now()) {}
  virtual ~Task() = default;

  // Does the actual work. Returns `true` if done.
  virtual bool doProgress() = 0;

  // Called by the scheduler when the task is cancelled by the scheduler.
  virtual void cancel() throw() {}

 protected:
  chrono::steady_clock::time_point startTime_;
};

/// Base class for tasks generated by a Thrift service handler.
///
/// The @ref cancel method's default implementation aborts the service
/// request using an exception.
///
template<class ReturnType>
class TaskFromRemote : public Task
{
 public:
  typedef function<void(ReturnType result)> cob_type;
  typedef function<void(::apache::thrift::TDelayedException* _throw)> exn_cob_type;

  explicit TaskFromRemote(cob_type cob, exn_cob_type exn_cob = exn_cob_type())
      : cob_(cob), exn_cob_(exn_cob) {
    // Intentionally left empty.
  }

  virtual void cancel() throw () override {
    cout << "Remote task canceled!" << endl;
    example::Error e;
    e.errorCode = example::ErrorCode::SERVICE_CMD_CANCELLED;
    e.__set_errorMessage("Cancelled by scheduler.");
    exn_cob_(::apache::thrift::TDelayedException::delayException(e));
  }

 protected:
  cob_type cob_;
  exn_cob_type exn_cob_;
};


/// The trivial cooperative scheduler.
///
/// Calls Task::doProgress every 25 ms for each currently registered @ref Task
/// A new @ref Task can be added with @ref addTask.
///
/// Use @ref start to start the scheduler thread and @ref stop to request the
/// scheduler to stop.
///
class TrivialCooperativeScheduler
{
 public:
  void addTask(shared_ptr<Task> task) {
    if (!stopped_) {
      lock_guard<mutex> guard(tasksMutex_);
      tasks_.push_back(task);
    } else {
      task->cancel();  // Make sure
    }
  }

  /// Starts processing the tasks.
  void start() {
    bool b = true;
    std::swap(started_, b);
    if (b)
      return;

    while (!stopped_) {
      doIteration();
      this_thread::sleep_for(chrono::milliseconds(25));
    }

    for (auto & task : tasks_)
      task->cancel();
  }

  /// Requests the scheduler to stop processing tasks.
  void stop() {
    stopped_ = true;
  }

 private:
  void doIteration() {
    lock_guard<mutex> guard(tasksMutex_);
    for (auto iter = tasks_.begin(); iter != tasks_.end();) {
      auto task = *iter;

      bool done = false;
      try {
        done = task->doProgress();
      } catch (...) {
        task->cancel();
        done = true;  // Just get rid of it.
      }

      if (done) {
        iter = tasks_.erase(iter);
      } else {
        ++iter;
      }
    }
  }

  list<shared_ptr<Task>> tasks_;
  mutex tasksMutex_;
  bool started_ = false;
  bool stopped_ = false;
};

#endif /* H06FC1744_A51C_4B59_8363_B313BF18EF8F */
